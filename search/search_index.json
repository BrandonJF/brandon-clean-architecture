{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Brandon's Clean Architecture Guide","text":"<p>Purpose: A definitive guide to my clean architecture style, optimized for TypeScript/Next.js projects with strong functional programming bias, SOLID principles, and pragmatic developer ergonomics.</p> <p>Last Updated: 2025-12-09 Author: Brandon John-Freso License: MIT</p>"},{"location":"#about-this-guide","title":"About This Guide","text":"<p>This is a comprehensive, opinionated guide to Clean Architecture for TypeScript and Next.js projects. It reflects my personal preferences built over years of building production systems.</p>"},{"location":"#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to structure TypeScript/Next.js projects with Clean Architecture</li> <li>Feature-first directory organization (not layer-first)</li> <li>Dependency inversion and composition patterns</li> <li>Testing strategies with test doubles (not mocking frameworks)</li> <li>Next.js integration patterns</li> <li>Migration strategies from messy codebases</li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<p>\"Always follow clean arch, it's not that much overhead.\"</p> <p>This guide prioritizes: - Domain isolation - Developer ergonomics - Fast tests (&lt;50ms for unit tests) - Simple, clear vocabulary (no heavy jargon) - Functional programming bias</p>"},{"location":"#how-to-use-this-guide","title":"How to Use This Guide","text":"<p>Navigate through the sections in the sidebar. Each section is standalone but builds on previous concepts.</p> <p>Start with Philosophy &amp; Core Principles to understand the why, then move through the architectural layers and patterns.</p>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Philosophy &amp; Core Principles</li> <li>Architecture Layers</li> <li>Directory Structure</li> <li>Naming Conventions</li> <li>Dependency Management</li> <li>Type System &amp; Validation</li> <li>Testing Strategy</li> <li>Error Handling</li> <li>Code Style &amp; Patterns</li> <li>Next.js Integration</li> <li>Common Patterns</li> <li>Migration Strategies</li> <li>Summary: Quick Reference Checklist</li> <li>Appendix: Example Project Structure</li> </ul>"},{"location":"appendix-example-project-structure/","title":"Example Project","text":""},{"location":"appendix-example-project-structure/#appendix-example-project-structure","title":"Appendix: Example Project Structure","text":"<p>Complete example for reference:</p> <pre><code>my-next-app/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 features/\n\u2502   \u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 user.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 user.test.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 value-objects/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 email.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 email.test.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 user-id.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 user-repository.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 email-service.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 password-hasher.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 errors/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 user-errors.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 application/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 use-cases/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 register-user/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 register-user-use-case.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 register-user-use-case.test.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 types.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 login/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 login-use-case.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 login-use-case.test.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 types.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 infrastructure/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 prisma-user-repository.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 prisma-user-repository.integration.test.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 in-memory-user-repository.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 resend-email-service.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 bcrypt-password-hasher.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 fake-email-service.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 mappers/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 user-mapper.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 composition-root.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 composition-root.test.ts\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502\n\u2502   \u2502   \u2514\u2500\u2500 billing/\n\u2502   \u2502       \u251c\u2500\u2500 domain/\n\u2502   \u2502       \u251c\u2500\u2500 application/\n\u2502   \u2502   \u251c\u2500\u2500 infrastructure/\n\u2502   \u2502       \u251c\u2500\u2500 composition-root.ts\n\u2502   \u2502       \u2514\u2500\u2500 index.ts\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 ui/\n\u2502   \u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 login-form.tsx\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 register-form.tsx\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 shared/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 button.tsx\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 input.tsx\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 card.tsx\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 use-auth.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 use-form.ts\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 core/\n\u2502   \u2502   \u251c\u2500\u2500 errors/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 base-error.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 domain-error.ts\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u251c\u2500\u2500 types/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 common.ts\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2514\u2500\u2500 utils/\n\u2502   \u2502       \u251c\u2500\u2500 date.ts\n\u2502   \u2502       \u251c\u2500\u2500 string.ts\n\u2502   \u2502       \u2514\u2500\u2500 index.ts\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 config/\n\u2502       \u251c\u2500\u2500 env.ts\n\u2502       \u2514\u2500\u2500 constants.ts\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 (auth)/\n\u2502   \u2502   \u251c\u2500\u2500 login/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 page.tsx\n\u2502   \u2502   \u251c\u2500\u2500 register/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 page.tsx\n\u2502   \u2502   \u2514\u2500\u2500 layout.tsx\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 auth/\n\u2502   \u2502       \u251c\u2500\u2500 register/\n\u2502   \u2502       \u2502   \u2514\u2500\u2500 route.ts\n\u2502   \u2502       \u2514\u2500\u2500 login/\n\u2502   \u2502           \u2514\u2500\u2500 route.ts\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u2514\u2500\u2500 auth-actions.ts\n\u2502   \u2514\u2500\u2500 layout.tsx\n\u2502\n\u251c\u2500\u2500 prisma/\n\u2502   \u2514\u2500\u2500 schema.prisma\n\u2502\n\u251c\u2500\u2500 tests/\n\u2502   \u2514\u2500\u2500 e2e/\n\u2502       \u2514\u2500\u2500 auth.spec.ts\n\u2502\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 .env.example\n\u251c\u2500\u2500 tsconfig.json\n\u251c\u2500\u2500 next.config.js\n\u2514\u2500\u2500 package.json\n</code></pre> <p>End of Guide</p> <p>This is a living document. Update as architectural decisions evolve. Always follow clean arch, it's not that much overhead.</p> <p>Remember: - Domain is pure business logic - Application orchestrates use-cases - Infrastructure handles frameworks, APIs, databases - Always dependency inversion (interfaces over implementations) - Prefer test doubles over mocks - Functional programming bias (pure, immutable) - Feature folders with layers inside - Barrel exports everywhere - Next.js routes/actions call use-cases, never repositories directly</p> <p>When in doubt: Ask \"Does this violate dependency inversion?\" If yes, refactor.</p>"},{"location":"appendix-example-project-structure/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Summary: Quick Reference Checklist</p>"},{"location":"architecture-layers/","title":"Architecture Layers","text":""},{"location":"architecture-layers/#architecture-layers","title":"Architecture Layers","text":""},{"location":"architecture-layers/#the-three-layers","title":"The Three Layers","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Infrastructure (Outer)                \u2502\n\u2502   - Frameworks (Next.js, React)         \u2502\n\u2502   - External APIs (REST, GraphQL)       \u2502\n\u2502   - Databases (Prisma, Drizzle)         \u2502\n\u2502   - UI Components                       \u2502\n\u2502   - HTTP Handlers                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502 depends on \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Application (Middle)                  \u2502\n\u2502   - Use Cases                           \u2502\n\u2502   - Orchestration                       \u2502\n\u2502   - Application Services                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502 depends on \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Domain (Inner)                        \u2502\n\u2502   - Entities                            \u2502\n\u2502   - Value Objects                       \u2502\n\u2502   - Business Rules                      \u2502\n\u2502   - Repository Interfaces               \u2502\n\u2502   - Service Interfaces                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture-layers/#layer-rules","title":"Layer Rules","text":""},{"location":"architecture-layers/#domain-layer-innermost","title":"Domain Layer (Innermost)","text":"<p>Responsibilities: - Pure business logic and rules - Rich entities with behavior - Value objects (immutable, validated types) - Repository interfaces (contracts) - Service interfaces (e.g., <code>Llm</code>, <code>EmailService</code>)</p> <p>Import Rules: - \u2705 Can import: Other domain types only - \u274c Cannot import: Application, Infrastructure, Frameworks</p> <p>Examples: <pre><code>// domain/entities/user.ts\nexport class User {\n  private constructor(\n    public readonly id: UserId,\n    public readonly email: Email,\n    public readonly profile: UserProfile,\n    private status: UserStatus\n  ) {}\n\n  static create(props: CreateUserProps): User {\n    // Validate invariants\n    if (!props.email.isValid()) {\n      throw new InvalidEmailError(props.email.value);\n    }\n    return new User(/* ... */);\n  }\n\n  activate(): void {\n    if (this.status.isActive()) {\n      throw new UserAlreadyActiveError(this.id);\n    }\n    this.status = UserStatus.active();\n  }\n\n  // Domain rule: business logic method\n  canAccessFeature(feature: Feature): boolean {\n    return this.profile.tier.includes(feature) &amp;&amp; this.status.isActive();\n  }\n}\n\n// domain/repositories/user-repository.ts\nexport interface UserRepository {\n  findById(id: UserId): Promise&lt;User | null&gt;;\n  save(user: User): Promise&lt;void&gt;;\n  findByEmail(email: Email): Promise&lt;User | null&gt;;\n}\n\n// domain/services/email-service.ts\nexport interface EmailService {\n  sendWelcomeEmail(user: User): Promise&lt;void&gt;;\n  sendPasswordReset(email: Email, token: string): Promise&lt;void&gt;;\n}\n</code></pre></p>"},{"location":"architecture-layers/#application-layer-middle","title":"Application Layer (Middle)","text":"<p>Responsibilities: - Use cases (application-specific workflows) - Orchestrate domain entities and services - Define Input/Output types for operations - Application-level validation</p> <p>Import Rules: - \u2705 Can import: Domain (entities, interfaces, value objects) - \u274c Cannot import: Infrastructure, Frameworks</p> <p>Examples: <pre><code>// application/use-cases/register-user/register-user-use-case.ts\nexport interface RegisterUserInput {\n  email: string;\n  password: string;\n  name: string;\n}\n\nexport interface RegisterUserOutput {\n  userId: string;\n  success: boolean;\n}\n\nexport class RegisterUserUseCase {\n  constructor(\n    private userRepo: UserRepository,\n    private emailService: EmailService,\n    private passwordHasher: PasswordHasher\n  ) {}\n\n  async execute(input: RegisterUserInput): Promise&lt;RegisterUserOutput&gt; {\n    // 1. Create value objects\n    const email = Email.create(input.email);\n    const hashedPassword = await this.passwordHasher.hash(input.password);\n\n    // 2. Check business rules\n    const existing = await this.userRepo.findByEmail(email);\n    if (existing) {\n      throw new UserAlreadyExistsError(email);\n    }\n\n    // 3. Create entity\n    const user = User.create({\n      email,\n      password: hashedPassword,\n      profile: UserProfile.create({ name: input.name }),\n    });\n\n    // 4. Persist\n    await this.userRepo.save(user);\n\n    // 5. Side effects\n    await this.emailService.sendWelcomeEmail(user);\n\n    return {\n      userId: user.id.value,\n      success: true,\n    };\n  }\n}\n</code></pre></p>"},{"location":"architecture-layers/#infrastructure-layer-outermost","title":"Infrastructure Layer (Outermost)","text":"<p>Responsibilities: - Framework code (Next.js, React) - External system adapters (APIs, databases) - UI components - Repository implementations - Service implementations</p> <p>Import Rules: - \u2705 Can import: Domain, Application, External SDKs - \u2705 The only layer that imports frameworks</p> <p>Examples: <pre><code>// infrastructure/repositories/prisma-user-repository.ts\nexport class PrismaUserRepository implements UserRepository {\n  constructor(private prisma: PrismaClient) {}\n\n  async findById(id: UserId): Promise&lt;User | null&gt; {\n    const record = await this.prisma.user.findUnique({\n      where: { id: id.value },\n    });\n    return record ? UserMapper.toDomain(record) : null;\n  }\n\n  async save(user: User): Promise&lt;void&gt; {\n    const data = UserMapper.toPersistence(user);\n    await this.prisma.user.upsert({\n      where: { id: data.id },\n      update: data,\n      create: data,\n    });\n  }\n}\n\n// infrastructure/services/resend-email-service.ts\nexport class ResendEmailService implements EmailService {\n  constructor(private resend: Resend) {}\n\n  async sendWelcomeEmail(user: User): Promise&lt;void&gt; {\n    await this.resend.emails.send({\n      from: 'noreply@example.com',\n      to: user.email.value,\n      subject: 'Welcome!',\n      html: WelcomeEmailTemplate.render(user),\n    });\n  }\n}\n</code></pre></p>"},{"location":"architecture-layers/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Philosophy &amp; Core Principles</p> <p>Next: Directory Structure \u2192</p>"},{"location":"code-style-patterns/","title":"Code Style & Patterns","text":""},{"location":"code-style-patterns/#code-style-patterns","title":"Code Style &amp; Patterns","text":""},{"location":"code-style-patterns/#functional-programming-bias","title":"Functional Programming Bias","text":"<p>Prefer pure functions for domain logic.</p> <pre><code>// \u2705 CORRECT: Pure functions\nexport function calculateDiscount(price: Money, tier: UserTier): Money {\n  const discountRate = getDiscountRate(tier);\n  return price.multiply(1 - discountRate);\n}\n\nexport function isEligibleForRefund(order: Order, now: Date): boolean {\n  const daysSincePurchase = differenceInDays(now, order.purchasedAt);\n  return daysSincePurchase &lt;= 30 &amp;&amp; order.status === 'completed';\n}\n\n// \u274c WRONG: Impure, mutating\nexport function applyDiscount(order: Order, tier: UserTier): void {\n  const discount = getDiscountRate(tier);\n  order.total = order.total * (1 - discount); // \u274c Mutation\n  order.discountApplied = true; // \u274c Mutation\n}\n</code></pre>"},{"location":"code-style-patterns/#immutability","title":"Immutability","text":"<p>Use <code>const</code>, spread operators, no mutations.</p> <pre><code>// \u2705 CORRECT: Immutable updates\nexport class User {\n  constructor(\n    public readonly id: UserId,\n    public readonly email: Email,\n    private readonly preferences: UserPreferences\n  ) {}\n\n  updatePreferences(newPrefs: Partial&lt;UserPreferences&gt;): User {\n    return new User(\n      this.id,\n      this.email,\n      { ...this.preferences, ...newPrefs } // \u2705 Spread, no mutation\n    );\n  }\n}\n\n// \u274c WRONG: Mutation\nexport class User {\n  updatePreferences(newPrefs: Partial&lt;UserPreferences&gt;): void {\n    Object.assign(this.preferences, newPrefs); // \u274c Mutates\n  }\n}\n</code></pre>"},{"location":"code-style-patterns/#declarative-over-imperative","title":"Declarative Over Imperative","text":"<pre><code>// \u2705 CORRECT: Declarative\nconst activeUsers = users.filter(user =&gt; user.isActive());\nconst userNames = activeUsers.map(user =&gt; user.name);\nconst sortedNames = userNames.sort();\n\n// \u274c WRONG: Imperative\nconst activeUsers = [];\nfor (let i = 0; i &lt; users.length; i++) {\n  if (users[i].status === 'active') {\n    activeUsers.push(users[i]);\n  }\n}\nconst userNames = [];\nfor (let i = 0; i &lt; activeUsers.length; i++) {\n  userNames.push(activeUsers[i].name);\n}\nuserNames.sort();\n</code></pre>"},{"location":"code-style-patterns/#asyncawait-patterns","title":"Async/Await Patterns","text":"<p>Default: Use <code>async/await</code> for control flow.</p> <pre><code>// \u2705 CORRECT: async/await for control flow\nexport class RegisterUserUseCase {\n  async execute(input: RegisterUserInput): Promise&lt;RegisterUserOutput&gt; {\n    const email = Email.create(input.email);\n    const existing = await this.userRepo.findByEmail(email);\n\n    if (existing) {\n      throw new UserAlreadyExistsError(email);\n    }\n\n    const user = User.create({ email, ... });\n    await this.userRepo.save(user);\n    await this.emailService.sendWelcomeEmail(user);\n\n    return { userId: user.id.value, success: true };\n  }\n}\n\n// \u2705 CORRECT: Parallelize when possible\nexport class GetUserDashboardUseCase {\n  async execute(userId: UserId): Promise&lt;DashboardData&gt; {\n    const [user, orders, notifications] = await Promise.all([\n      this.userRepo.findById(userId),\n      this.orderRepo.findByUserId(userId),\n      this.notificationRepo.findByUserId(userId),\n    ]);\n\n    return { user, orders, notifications };\n  }\n}\n</code></pre>"},{"location":"code-style-patterns/#comments-principle-based","title":"Comments: Principle-Based","text":"<p>Comment why, not what. Focus on business rules and non-obvious decisions.</p> <pre><code>// \u2705 GOOD: Explains business rule\nexport class Invoice {\n  calculateTotal(): Money {\n    // Domain rule: Invoices over $1000 get automatic 5% enterprise discount\n    if (this.subtotal.greaterThan(Money.dollars(1000))) {\n      return this.subtotal.multiply(0.95);\n    }\n    return this.subtotal;\n  }\n\n  // Performance: Memoize to avoid recalculating on every render\n  @memoize\n  getLineItems(): LineItem[] {\n    return this.items.map(item =&gt; this.calculateLineItem(item));\n  }\n}\n\n// \u274c BAD: Comments the obvious\nexport class User {\n  // Get the user's email\n  getEmail(): Email {\n    return this.email; // Return the email\n  }\n}\n</code></pre>"},{"location":"code-style-patterns/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Error Handling</p> <p>Next: Next.js Integration \u2192</p>"},{"location":"common-patterns/","title":"Common Patterns","text":""},{"location":"common-patterns/#common-patterns","title":"Common Patterns","text":""},{"location":"common-patterns/#repository-pattern","title":"Repository Pattern","text":"<pre><code>// Domain interface\nexport interface UserRepository {\n  findById(id: UserId): Promise&lt;User | null&gt;;\n  findByEmail(email: Email): Promise&lt;User | null&gt;;\n  save(user: User): Promise&lt;void&gt;;\n  delete(id: UserId): Promise&lt;void&gt;;\n}\n\n// Prisma implementation\nexport class PrismaUserRepository implements UserRepository {\n  constructor(private prisma: PrismaClient) {}\n\n  async findById(id: UserId): Promise&lt;User | null&gt; {\n    const record = await this.prisma.user.findUnique({\n      where: { id: id.value },\n    });\n    return record ? UserMapper.toDomain(record) : null;\n  }\n\n  async save(user: User): Promise&lt;void&gt; {\n    const data = UserMapper.toPersistence(user);\n    await this.prisma.user.upsert({\n      where: { id: data.id },\n      update: data,\n      create: data,\n    });\n  }\n}\n\n// In-memory implementation (for testing)\nexport class InMemoryUserRepository implements UserRepository {\n  private users = new Map&lt;string, User&gt;();\n\n  async findById(id: UserId): Promise&lt;User | null&gt; {\n    return this.users.get(id.value) || null;\n  }\n\n  async save(user: User): Promise&lt;void&gt; {\n    this.users.set(user.id.value, user);\n  }\n\n  // Test helper\n  clear(): void {\n    this.users.clear();\n  }\n}\n</code></pre>"},{"location":"common-patterns/#mapper-pattern","title":"Mapper Pattern","text":"<p>Anti-corruption layer between infrastructure and domain.</p> <pre><code>// infrastructure/mappers/user-mapper.ts\nimport { User as PrismaUser } from '@prisma/client';\nimport { User, UserId, Email } from '@/features/auth/domain';\n\nexport class UserMapper {\n  static toDomain(raw: PrismaUser): User {\n    return User.create({\n      id: UserId.create(raw.id),\n      email: Email.create(raw.email),\n      profile: UserProfile.create({\n        name: raw.name,\n        tier: raw.tier as UserTier,\n      }),\n      status: raw.status as UserStatus,\n      createdAt: raw.createdAt,\n      updatedAt: raw.updatedAt,\n    });\n  }\n\n  static toPersistence(user: User): PrismaUserCreateInput {\n    return {\n      id: user.id.value,\n      email: user.email.value,\n      name: user.profile.name,\n      tier: user.profile.tier,\n      status: user.status,\n      createdAt: user.createdAt,\n      updatedAt: user.updatedAt,\n    };\n  }\n}\n</code></pre>"},{"location":"common-patterns/#use-case-pattern","title":"Use Case Pattern","text":"<pre><code>// Consistent structure for all use-cases\nexport interface &lt;Verb&gt;&lt;Noun&gt;Input {\n  // Input fields\n}\n\nexport interface &lt;Verb&gt;&lt;Noun&gt;Output {\n  // Output fields\n}\n\nexport class &lt;Verb&gt;&lt;Noun&gt;UseCase {\n  constructor(\n    private repo: Repository,\n    private service: Service\n  ) {}\n\n  async execute(input: &lt;Verb&gt;&lt;Noun&gt;Input): Promise&lt;&lt;Verb&gt;&lt;Noun&gt;Output&gt; {\n    // 1. Validate &amp; create value objects\n    // 2. Fetch entities from repositories\n    // 3. Apply business rules\n    // 4. Persist changes\n    // 5. Trigger side effects (emails, events)\n    // 6. Return output\n  }\n}\n</code></pre>"},{"location":"common-patterns/#value-object-pattern","title":"Value Object Pattern","text":"<pre><code>export class Email {\n  private constructor(public readonly value: string) {}\n\n  static create(value: string): Email {\n    if (!this.isValid(value)) {\n      throw new InvalidEmailError(value);\n    }\n    return new Email(value.toLowerCase().trim());\n  }\n\n  private static isValid(value: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(value) &amp;&amp; value.length &lt;= 255;\n  }\n\n  equals(other: Email): boolean {\n    return this.value === other.value;\n  }\n}\n</code></pre>"},{"location":"common-patterns/#entity-pattern","title":"Entity Pattern","text":"<pre><code>export class User {\n  private constructor(\n    public readonly id: UserId,\n    public readonly email: Email,\n    private status: UserStatus,\n    public readonly createdAt: Date,\n    private updatedAt: Date\n  ) {}\n\n  static create(props: CreateUserProps): User {\n    // Validate invariants\n    return new User(\n      props.id,\n      props.email,\n      props.status || UserStatus.active(),\n      new Date(),\n      new Date()\n    );\n  }\n\n  // Business logic methods\n  activate(): void {\n    if (this.status === UserStatus.active()) {\n      throw new UserAlreadyActiveError(this.id);\n    }\n    this.status = UserStatus.active();\n    this.touch();\n  }\n\n  suspend(): void {\n    this.status = UserStatus.suspended();\n    this.touch();\n  }\n\n  private touch(): void {\n    this.updatedAt = new Date();\n  }\n}\n</code></pre>"},{"location":"common-patterns/#transaction-pattern","title":"Transaction Pattern","text":"<p>Transactions handled in use-cases, mechanism provided by repositories.</p> <pre><code>// Domain interface defines transaction capability\nexport interface UserRepository {\n  // ... other methods\n  transaction&lt;T&gt;(work: (repo: UserRepository) =&gt; Promise&lt;T&gt;): Promise&lt;T&gt;;\n}\n\n// Prisma implementation provides mechanism\nexport class PrismaUserRepository implements UserRepository {\n  async transaction&lt;T&gt;(work: (repo: UserRepository) =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {\n    return this.prisma.$transaction(async (tx) =&gt; {\n      const txRepo = new PrismaUserRepository(tx as PrismaClient);\n      return work(txRepo);\n    });\n  }\n}\n\n// Use-case orchestrates transaction\nexport class TransferCreditsUseCase {\n  constructor(private userRepo: UserRepository) {}\n\n  async execute(input: TransferCreditsInput): Promise&lt;TransferCreditsOutput&gt; {\n    return this.userRepo.transaction(async (repo) =&gt; {\n      const sender = await repo.findById(input.senderId);\n      const receiver = await repo.findById(input.receiverId);\n\n      if (!sender || !receiver) {\n        throw new UserNotFoundError();\n      }\n\n      sender.deductCredits(input.amount);\n      receiver.addCredits(input.amount);\n\n      await repo.save(sender);\n      await repo.save(receiver);\n\n      return { success: true };\n    });\n  }\n}\n</code></pre>"},{"location":"common-patterns/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Next.js Integration</p> <p>Next: Migration Strategies \u2192</p>"},{"location":"dependency-management/","title":"Dependency Management","text":""},{"location":"dependency-management/#dependency-management","title":"Dependency Management","text":""},{"location":"dependency-management/#dependency-inversion-principle","title":"Dependency Inversion Principle","text":"<p>Rule: High-level modules (use-cases) should not depend on low-level modules (databases, APIs). Both should depend on abstractions (interfaces).</p>"},{"location":"dependency-management/#pattern-interface-in-domain-implementation-in-infrastructure","title":"Pattern: Interface in Domain, Implementation in Infrastructure","text":"<pre><code>// \u2705 CORRECT\n// domain/repositories/user-repository.ts\nexport interface UserRepository {\n  findById(id: UserId): Promise&lt;User | null&gt;;\n  save(user: User): Promise&lt;void&gt;;\n}\n\n// infrastructure/repositories/prisma-user-repository.ts\nexport class PrismaUserRepository implements UserRepository {\n  constructor(private prisma: PrismaClient) {}\n\n  async findById(id: UserId): Promise&lt;User | null&gt; {\n    // Prisma-specific implementation\n  }\n}\n\n// application/use-cases/get-user/get-user-use-case.ts\nexport class GetUserUseCase {\n  constructor(private userRepo: UserRepository) {} // \u2705 Depends on interface\n\n  async execute(input: GetUserInput): Promise&lt;GetUserOutput&gt; {\n    const user = await this.userRepo.findById(input.userId);\n    // ...\n  }\n}\n</code></pre> <pre><code>// \u274c WRONG\n// application/use-cases/get-user/get-user-use-case.ts\nimport { PrismaClient } from '@prisma/client'; // \u274c Application depends on framework\n\nexport class GetUserUseCase {\n  constructor(private prisma: PrismaClient) {} // \u274c Depends on concrete implementation\n\n  async execute(input: GetUserInput): Promise&lt;GetUserOutput&gt; {\n    const user = await this.prisma.user.findUnique({ where: { id: input.userId } });\n    // \u274c Use-case knows about database structure\n  }\n}\n</code></pre>"},{"location":"dependency-management/#constructor-injection","title":"Constructor Injection","text":"<p>All dependencies must be injected via constructor parameters.</p> <pre><code>// \u2705 CORRECT: Dependencies injected\nexport class RegisterUserUseCase {\n  constructor(\n    private userRepo: UserRepository,\n    private emailService: EmailService,\n    private passwordHasher: PasswordHasher\n  ) {}\n}\n\n// \u274c WRONG: Dependencies created inside class\nexport class RegisterUserUseCase {\n  private userRepo = new PrismaUserRepository(new PrismaClient()); // \u274c\n  private emailService = new ResendEmailService(new Resend()); // \u274c\n}\n\n// \u274c WRONG: Importing singletons\nimport { db } from '@/lib/db'; // \u274c\n\nexport class RegisterUserUseCase {\n  async execute(input: RegisterUserInput) {\n    const user = await db.user.findUnique({ ... }); // \u274c\n  }\n}\n</code></pre>"},{"location":"dependency-management/#composition-root-pattern","title":"Composition Root Pattern","text":"<p>Single location per feature where all dependencies are wired together.</p> <pre><code>// features/auth/composition-root.ts\nimport { PrismaClient } from '@prisma/client';\nimport { Resend } from 'resend';\nimport { RegisterUserUseCase } from './application';\nimport { PrismaUserRepository, ResendEmailService } from './infrastructure';\nimport { BCryptPasswordHasher } from './infrastructure/services/bcrypt-password-hasher';\n\nexport function createAuthCompositionRoot(config: {\n  prisma: PrismaClient;\n  resendApiKey: string;\n}) {\n  // Infrastructure implementations\n  const userRepo = new PrismaUserRepository(config.prisma);\n  const emailService = new ResendEmailService(new Resend(config.resendApiKey));\n  const passwordHasher = new BCryptPasswordHasher();\n\n  // Use cases\n  const registerUserUseCase = new RegisterUserUseCase(\n    userRepo,\n    emailService,\n    passwordHasher\n  );\n\n  const loginUseCase = new LoginUseCase(userRepo, passwordHasher);\n\n  // Return use cases (public API)\n  return {\n    registerUser: registerUserUseCase,\n    login: loginUseCase,\n  };\n}\n\n// Usage in Next.js API route\n// app/api/auth/register/route.ts\nimport { createAuthCompositionRoot } from '@/features/auth/composition-root';\nimport { prisma } from '@/lib/prisma';\n\nexport async function POST(request: Request) {\n  const auth = createAuthCompositionRoot({\n    prisma,\n    resendApiKey: process.env.RESEND_API_KEY!,\n  });\n\n  const body = await request.json();\n  const result = await auth.registerUser.execute(body);\n\n  return Response.json(result);\n}\n</code></pre>"},{"location":"dependency-management/#test-composition-root","title":"Test Composition Root","text":"<pre><code>// features/auth/composition-root.test.ts\nexport function createTestAuthCompositionRoot() {\n  // Test doubles\n  const userRepo = new InMemoryUserRepository();\n  const emailService = new FakeEmailService();\n  const passwordHasher = new FakePasswordHasher();\n\n  // Use cases with test doubles\n  const registerUserUseCase = new RegisterUserUseCase(\n    userRepo,\n    emailService,\n    passwordHasher\n  );\n\n  return {\n    registerUser: registerUserUseCase,\n    // Test helpers\n    testHelpers: {\n      userRepo, // Expose for assertions\n      emailService,\n    },\n  };\n}\n</code></pre>"},{"location":"dependency-management/#no-di-containers","title":"No DI Containers","text":"<p>Prefer explicit composition over DI containers (InversifyJS, tsyringe, etc.)</p> <p>Why: - \u2705 Type safety: TypeScript checks all wiring at compile time - \u2705 Simplicity: No decorators, no reflection, no magic - \u2705 Debuggability: Clear call stacks - \u2705 IDE support: Go-to-definition works perfectly</p>"},{"location":"dependency-management/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Naming Conventions</p> <p>Next: Type System &amp; Validation \u2192</p>"},{"location":"directory-structure/","title":"Directory Structure","text":""},{"location":"directory-structure/#directory-structure","title":"Directory Structure","text":""},{"location":"directory-structure/#feature-based-organization-preferred","title":"Feature-Based Organization (Preferred)","text":"<p>Organize by feature first, then layer within feature:</p> <pre><code>src/\n\u251c\u2500\u2500 features/                          # Feature modules\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 user.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 value-objects/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 email.ts\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 user-id.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 user-repository.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 email-service.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 errors/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 user-errors.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts               # Barrel export\n\u2502   \u2502   \u251c\u2500\u2500 application/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 use-cases/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 register-user/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 register-user-use-case.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 types.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 login/\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 login-use-case.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 types.ts\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u251c\u2500\u2500 infrastructure/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 prisma-user-repository.ts\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 in-memory-user-repository.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 resend-email-service.ts\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 fake-email-service.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 mappers/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 user-mapper.ts\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u251c\u2500\u2500 composition-root.ts        # DI wiring for this feature\n\u2502   \u2502   \u2514\u2500\u2500 index.ts                   # Feature public API\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 billing/\n\u2502   \u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u251c\u2500\u2500 application/\n\u2502   \u2502   \u251c\u2500\u2500 infrastructure/\n\u2502   \u2502   \u251c\u2500\u2500 composition-root.ts\n\u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 analytics/\n\u2502       \u251c\u2500\u2500 domain/\n\u2502       \u251c\u2500\u2500 application/\n\u2502       \u251c\u2500\u2500 infrastructure/\n\u2502       \u251c\u2500\u2500 composition-root.ts\n\u2502       \u2514\u2500\u2500 index.ts\n\u2502\n\u251c\u2500\u2500 ui/                                # UI layer (Next.js specific)\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 login-form.tsx\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 register-form.tsx\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u251c\u2500\u2500 shared/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 button.tsx\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 card.tsx\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u2502   \u251c\u2500\u2500 use-auth.ts\n\u2502   \u2502   \u251c\u2500\u2500 use-user.ts\n\u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2514\u2500\u2500 index.ts\n\u2502\n\u251c\u2500\u2500 app/                               # Next.js app directory\n\u2502   \u251c\u2500\u2500 (auth)/\n\u2502   \u2502   \u251c\u2500\u2500 login/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 page.tsx\n\u2502   \u2502   \u2514\u2500\u2500 register/\n\u2502   \u2502       \u2514\u2500\u2500 page.tsx\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 auth/\n\u2502   \u2502       \u2514\u2500\u2500 register/\n\u2502   \u2502           \u2514\u2500\u2500 route.ts\n\u2502   \u2514\u2500\u2500 layout.tsx\n\u2502\n\u251c\u2500\u2500 core/                              # Cross-cutting concerns\n\u2502   \u251c\u2500\u2500 errors/\n\u2502   \u2502   \u251c\u2500\u2500 base-error.ts\n\u2502   \u2502   \u251c\u2500\u2500 domain-error.ts\n\u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u251c\u2500\u2500 types/\n\u2502   \u2502   \u251c\u2500\u2500 common.ts\n\u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2514\u2500\u2500 utils/\n\u2502       \u251c\u2500\u2500 date.ts\n\u2502       \u251c\u2500\u2500 string.ts\n\u2502       \u2514\u2500\u2500 index.ts\n\u2502\n\u2514\u2500\u2500 config/\n    \u251c\u2500\u2500 env.ts\n    \u2514\u2500\u2500 constants.ts\n</code></pre>"},{"location":"directory-structure/#key-principles","title":"Key Principles","text":"<ol> <li>Feature folders contain all layers - <code>features/{feature}/{domain,application,infrastructure}</code></li> <li>Barrel exports everywhere - Every directory has <code>index.ts</code></li> <li>Types in separate files - <code>types.ts</code> for clarity, co-located with implementation</li> <li>UI separated - <code>ui/</code> folder for React components, hooks</li> <li>App is infrastructure - Next.js <code>app/</code> directory is framework layer</li> <li>Shared concerns in <code>core/</code> - Not <code>lib/</code>, not <code>shared/</code>, use <code>core/</code> sparingly</li> </ol>"},{"location":"directory-structure/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Architecture Layers</p> <p>Next: Naming Conventions \u2192</p>"},{"location":"error-handling/","title":"Error Handling","text":""},{"location":"error-handling/#error-handling","title":"Error Handling","text":""},{"location":"error-handling/#custom-domain-errors","title":"Custom Domain Errors","text":"<p>Define custom error classes in domain layer.</p> <pre><code>// domain/errors/user-errors.ts\nexport class UserError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'UserError';\n  }\n}\n\nexport class InvalidEmailError extends UserError {\n  constructor(email: string) {\n    super(`Invalid email: ${email}`);\n    this.name = 'InvalidEmailError';\n  }\n}\n\nexport class UserNotFoundError extends UserError {\n  constructor(userId: string) {\n    super(`User not found: ${userId}`);\n    this.name = 'UserNotFoundError';\n  }\n}\n\nexport class UserAlreadyExistsError extends UserError {\n  constructor(email: Email) {\n    super(`User already exists with email: ${email.value}`);\n    this.name = 'UserAlreadyExistsError';\n  }\n}\n</code></pre>"},{"location":"error-handling/#error-propagation-push-upward","title":"Error Propagation: Push Upward","text":"<p>Domain/use-cases throw errors. Infrastructure handles them.</p> <pre><code>// \u2705 CORRECT: Use-case throws domain errors\nexport class RegisterUserUseCase {\n  async execute(input: RegisterUserInput): Promise&lt;RegisterUserOutput&gt; {\n    const email = Email.create(input.email); // May throw InvalidEmailError\n\n    const existing = await this.userRepo.findByEmail(email);\n    if (existing) {\n      throw new UserAlreadyExistsError(email); // \u2705 Throw domain error\n    }\n\n    const user = User.create({ email, ... });\n    await this.userRepo.save(user);\n\n    return { userId: user.id.value, success: true };\n  }\n}\n\n// Infrastructure layer (API route) handles errors\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const result = await auth.registerUser.execute(body);\n    return Response.json(result);\n  } catch (error) {\n    if (error instanceof UserAlreadyExistsError) {\n      return Response.json({ error: error.message }, { status: 409 });\n    }\n    if (error instanceof InvalidEmailError) {\n      return Response.json({ error: error.message }, { status: 400 });\n    }\n    // Unknown error\n    console.error('Unexpected error:', error);\n    return Response.json({ error: 'Internal server error' }, { status: 500 });\n  }\n}\n</code></pre>"},{"location":"error-handling/#no-swallowing-errors-in-core-logic","title":"No Swallowing Errors in Core Logic","text":"<pre><code>// \u274c WRONG: Swallowing errors in use-case\nexport class RegisterUserUseCase {\n  async execute(input: RegisterUserInput): Promise&lt;RegisterUserOutput&gt; {\n    try {\n      const user = User.create({ ... });\n      await this.userRepo.save(user);\n      return { success: true };\n    } catch (error) {\n      console.error(error); // \u274c Swallowed\n      return { success: false }; // \u274c Caller doesn't know what happened\n    }\n  }\n}\n\n// \u2705 CORRECT: Let errors bubble up\nexport class RegisterUserUseCase {\n  async execute(input: RegisterUserInput): Promise&lt;RegisterUserOutput&gt; {\n    const user = User.create({ ... }); // May throw\n    await this.userRepo.save(user); // May throw\n    return { success: true }; // Only reached if successful\n  }\n}\n</code></pre>"},{"location":"error-handling/#logging-strategy","title":"Logging Strategy","text":"<p>Logging is a side effect \u2192 belongs in infrastructure.</p> <pre><code>// \u274c WRONG: Logging in domain\nexport class User {\n  activate(): void {\n    console.log('Activating user:', this.id); // \u274c Side effect in domain\n    this.status = 'active';\n  }\n}\n\n// \u2705 CORRECT: Logging in infrastructure\nexport async function POST(request: Request) {\n  try {\n    const result = await auth.registerUser.execute(body);\n    console.log('User registered:', result.userId); // \u2705 Log in infrastructure\n    return Response.json(result);\n  } catch (error) {\n    console.error('Registration failed:', error); // \u2705 Log in infrastructure\n    throw error;\n  }\n}\n</code></pre>"},{"location":"error-handling/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Testing Strategy</p> <p>Next: Code Style &amp; Patterns \u2192</p>"},{"location":"migration-strategies/","title":"Migration Strategies","text":""},{"location":"migration-strategies/#migration-strategies","title":"Migration Strategies","text":""},{"location":"migration-strategies/#from-messy-codebase-to-clean-architecture","title":"From Messy Codebase to Clean Architecture","text":"<p>Incremental approach - don't rewrite everything at once.</p>"},{"location":"migration-strategies/#phase-1-extract-domain-logic","title":"Phase 1: Extract Domain Logic","text":"<ol> <li>Identify business rules scattered across codebase</li> <li>Create domain entities and value objects</li> <li>Move business logic into entity methods</li> <li>Keep existing infrastructure as-is</li> </ol> <p>Example: <pre><code>// Before: Business logic in API route\nexport async function POST(request: Request) {\n  const body = await request.json();\n\n  // \u274c Business logic here\n  if (!body.email.includes('@')) {\n    return Response.json({ error: 'Invalid email' });\n  }\n\n  const user = await prisma.user.create({ data: body });\n  return Response.json(user);\n}\n\n// After: Extract to domain\nexport async function POST(request: Request) {\n  const body = await request.json();\n\n  try {\n    const email = Email.create(body.email); // \u2705 Domain validation\n    // ... still using prisma directly, but domain logic extracted\n  } catch (error) {\n    return Response.json({ error: error.message });\n  }\n}\n</code></pre></p>"},{"location":"migration-strategies/#phase-2-introduce-repository-interfaces","title":"Phase 2: Introduce Repository Interfaces","text":"<ol> <li>Define repository interfaces in domain</li> <li>Create adapters for existing data access</li> <li>Gradually replace direct DB calls with repository calls</li> </ol>"},{"location":"migration-strategies/#phase-3-extract-use-cases","title":"Phase 3: Extract Use Cases","text":"<ol> <li>Identify operations (user registration, order creation, etc.)</li> <li>Create use-case classes</li> <li>Move orchestration logic into use-cases</li> <li>Update routes to call use-cases</li> </ol>"},{"location":"migration-strategies/#phase-4-complete-clean-architecture","title":"Phase 4: Complete Clean Architecture","text":"<ol> <li>Organize into feature folders</li> <li>Add test doubles</li> <li>Complete dependency inversion</li> <li>Full separation of concerns</li> </ol>"},{"location":"migration-strategies/#adding-clean-architecture-to-new-features","title":"Adding Clean Architecture to New Features","text":"<p>Start clean from day one on new features.</p> <pre><code>// New feature: Billing\n// 1. Create feature folder\nfeatures/billing/\n\u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u2514\u2500\u2500 invoice.ts\n\u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u2514\u2500\u2500 invoice-repository.ts\n\u2502   \u2514\u2500\u2500 index.ts\n\u251c\u2500\u2500 application/\n\u2502   \u2514\u2500\u2500 use-cases/\n\u2502       \u2514\u2500\u2500 create-invoice/\n\u2502           \u251c\u2500\u2500 create-invoice-use-case.ts\n\u2502           \u251c\u2500\u2500 types.ts\n\u2502           \u2514\u2500\u2500 index.ts\n\u251c\u2500\u2500 infrastructure/\n\u2502   \u2514\u2500\u2500 repositories/\n\u2502       \u2514\u2500\u2500 prisma-invoice-repository.ts\n\u251c\u2500\u2500 composition-root.ts\n\u2514\u2500\u2500 index.ts\n\n// 2. Build feature with clean architecture\n// 3. Integrate with existing (messy) codebase via composition root\n// 4. Gradually refactor old features to match\n</code></pre>"},{"location":"migration-strategies/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Common Patterns</p> <p>Next: Summary: Quick Reference Checklist \u2192</p>"},{"location":"naming-conventions/","title":"Naming Conventions","text":""},{"location":"naming-conventions/#naming-conventions","title":"Naming Conventions","text":""},{"location":"naming-conventions/#files","title":"Files","text":"Type Pattern Examples Use Case <code>&lt;verb&gt;-&lt;noun&gt;-use-case.ts</code> <code>register-user-use-case.ts</code>, <code>calculate-invoice-use-case.ts</code> Entity <code>&lt;noun&gt;.ts</code> <code>user.ts</code>, <code>invoice.ts</code>, <code>subscription.ts</code> Value Object <code>&lt;noun&gt;.ts</code> <code>email.ts</code>, <code>user-id.ts</code>, <code>money.ts</code> Repository Interface <code>&lt;noun&gt;-repository.ts</code> <code>user-repository.ts</code>, <code>order-repository.ts</code> Repository Impl <code>&lt;source&gt;-&lt;noun&gt;-repository.ts</code> <code>prisma-user-repository.ts</code>, <code>in-memory-user-repository.ts</code> Service Interface <code>&lt;noun&gt;-service.ts</code> <code>email-service.ts</code>, <code>payment-service.ts</code> Service Impl <code>&lt;provider&gt;-&lt;noun&gt;-service.ts</code> <code>resend-email-service.ts</code>, <code>stripe-payment-service.ts</code> Mapper <code>&lt;noun&gt;-mapper.ts</code> <code>user-mapper.ts</code>, <code>invoice-mapper.ts</code> Test Double <code>fake-&lt;noun&gt;.ts</code> or <code>in-memory-&lt;noun&gt;.ts</code> <code>fake-email-service.ts</code>, <code>in-memory-user-repository.ts</code> Types <code>types.ts</code> Co-located with implementation Errors <code>&lt;domain&gt;-errors.ts</code> <code>user-errors.ts</code>, <code>auth-errors.ts</code> Component <code>&lt;noun&gt;.tsx</code> or <code>&lt;noun&gt;-&lt;type&gt;.tsx</code> <code>button.tsx</code>, <code>login-form.tsx</code> Hook <code>use-&lt;noun&gt;.ts</code> <code>use-auth.ts</code>, <code>use-user-data.ts</code> Barrel Export <code>index.ts</code> Every directory"},{"location":"naming-conventions/#classes-interfaces","title":"Classes &amp; Interfaces","text":"Type Pattern Examples Use Case <code>&lt;Verb&gt;&lt;Noun&gt;UseCase</code> <code>RegisterUserUseCase</code>, <code>CalculateInvoiceUseCase</code> Entity <code>&lt;Noun&gt;</code> <code>User</code>, <code>Invoice</code>, <code>Subscription</code> Value Object <code>&lt;Noun&gt;</code> <code>Email</code>, <code>UserId</code>, <code>Money</code> Repository <code>&lt;Noun&gt;Repository</code> (interface) <code>UserRepository</code>, <code>OrderRepository</code> Repository Impl <code>&lt;Source&gt;&lt;Noun&gt;Repository</code> <code>PrismaUserRepository</code>, <code>InMemoryUserRepository</code> Service <code>&lt;Noun&gt;Service</code> (interface) <code>EmailService</code>, <code>PaymentService</code> Service Impl <code>&lt;Provider&gt;&lt;Noun&gt;Service</code> <code>ResendEmailService</code>, <code>StripePaymentService</code> Error <code>&lt;Noun&gt;Error</code> <code>InvalidEmailError</code>, <code>UserNotFoundError</code> Mapper <code>&lt;Noun&gt;Mapper</code> <code>UserMapper</code>, <code>InvoiceMapper</code> Config <code>&lt;Noun&gt;Config</code> <code>EmailConfig</code>, <code>DatabaseConfig</code>"},{"location":"naming-conventions/#variables-constants","title":"Variables &amp; Constants","text":"<pre><code>// Constants: SCREAMING_SNAKE_CASE\nexport const MAX_LOGIN_ATTEMPTS = 5;\nexport const DEFAULT_TIMEOUT_MS = 3000;\n\n// Variables: camelCase\nconst userId = UserId.create(rawId);\nconst isValid = email.validate();\n\n// Private class members: camelCase with 'private' keyword (not underscore prefix)\nclass User {\n  private status: UserStatus; // \u2705\n  private _status: UserStatus; // \u274c Avoid underscore prefix\n}\n\n// Booleans: is/has/can prefix\nconst isActive = user.status.isActive();\nconst hasPermission = user.canAccessFeature(feature);\n</code></pre>"},{"location":"naming-conventions/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Directory Structure</p> <p>Next: Dependency Management \u2192</p>"},{"location":"nextjs-integration/","title":"Next.js Integration","text":""},{"location":"nextjs-integration/#nextjs-integration","title":"Next.js Integration","text":""},{"location":"nextjs-integration/#layer-mapping","title":"Layer Mapping","text":"Next.js Concept Clean Architecture Layer Purpose <code>app/*/page.tsx</code> Infrastructure (UI) Framework component <code>app/*/route.ts</code> Infrastructure (Handler) HTTP entrypoint Server Actions Infrastructure (Handler) Form submission entrypoint <code>components/*.tsx</code> Infrastructure (UI) React components <code>hooks/use*.ts</code> Infrastructure (UI) UI state management Middleware Infrastructure Request interceptor Server Components Infrastructure (UI) Default rendering mode Client Components Infrastructure (UI) Browser APIs, state"},{"location":"nextjs-integration/#ui-layer-organization","title":"UI Layer Organization","text":"<pre><code>src/\n\u251c\u2500\u2500 ui/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 login-form.tsx\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 register-form.tsx\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u251c\u2500\u2500 shared/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 button.tsx\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 input.tsx\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u2502   \u251c\u2500\u2500 use-auth.ts\n\u2502   \u2502   \u251c\u2500\u2500 use-form.ts\n\u2502   \u2502   \u2514\u2500\u2500 index.ts\n\u2502   \u2514\u2500\u2500 index.ts\n</code></pre>"},{"location":"nextjs-integration/#api-routes-must-call-use-cases","title":"API Routes Must Call Use-Cases","text":"<p>API routes are thin handlers that delegate to use-cases.</p> <pre><code>// \u2705 CORRECT: Route calls use-case\n// app/api/auth/register/route.ts\nimport { createAuthCompositionRoot } from '@/features/auth/composition-root';\nimport { prisma } from '@/lib/prisma';\n\nexport async function POST(request: Request) {\n  const auth = createAuthCompositionRoot({\n    prisma,\n    resendApiKey: process.env.RESEND_API_KEY!,\n  });\n\n  try {\n    const body = await request.json();\n    const result = await auth.registerUser.execute(body); // \u2705 Calls use-case\n    return Response.json(result);\n  } catch (error) {\n    if (error instanceof UserAlreadyExistsError) {\n      return Response.json({ error: error.message }, { status: 409 });\n    }\n    throw error;\n  }\n}\n</code></pre> <pre><code>// \u274c WRONG: Route has business logic\n// app/api/auth/register/route.ts\nimport { prisma } from '@/lib/prisma';\nimport bcrypt from 'bcrypt';\n\nexport async function POST(request: Request) {\n  const body = await request.json();\n\n  // \u274c Business logic in route handler\n  const existing = await prisma.user.findUnique({\n    where: { email: body.email },\n  });\n\n  if (existing) {\n    return Response.json({ error: 'User exists' }, { status: 409 });\n  }\n\n  const hashedPassword = await bcrypt.hash(body.password, 10);\n\n  const user = await prisma.user.create({\n    data: {\n      email: body.email,\n      password: hashedPassword,\n      name: body.name,\n    },\n  });\n\n  return Response.json({ userId: user.id });\n}\n</code></pre>"},{"location":"nextjs-integration/#server-actions-pattern","title":"Server Actions Pattern","text":"<pre><code>// app/actions/auth-actions.ts\n'use server';\n\nimport { createAuthCompositionRoot } from '@/features/auth/composition-root';\nimport { prisma } from '@/lib/prisma';\n\nexport async function registerUserAction(formData: FormData) {\n  const auth = createAuthCompositionRoot({\n    prisma,\n    resendApiKey: process.env.RESEND_API_KEY!,\n  });\n\n  try {\n    const result = await auth.registerUser.execute({\n      email: formData.get('email') as string,\n      password: formData.get('password') as string,\n      name: formData.get('name') as string,\n    });\n\n    return { success: true, userId: result.userId };\n  } catch (error) {\n    if (error instanceof UserAlreadyExistsError) {\n      return { success: false, error: 'User already exists' };\n    }\n    return { success: false, error: 'Registration failed' };\n  }\n}\n</code></pre>"},{"location":"nextjs-integration/#react-components-are-ui-layer","title":"React Components Are UI Layer","text":"<p>Components should NOT import domain entities or use-cases directly.</p> <pre><code>// \u2705 CORRECT: Component uses server action (infrastructure)\n'use client';\n\nimport { registerUserAction } from '@/app/actions/auth-actions';\nimport { Button, Input } from '@/ui/components/shared';\n\nexport function RegisterForm() {\n  async function handleSubmit(formData: FormData) {\n    const result = await registerUserAction(formData);\n\n    if (result.success) {\n      // Handle success\n    } else {\n      // Handle error\n    }\n  }\n\n  return (\n    &lt;form action={handleSubmit}&gt;\n      &lt;Input name=\"email\" type=\"email\" /&gt;\n      &lt;Input name=\"password\" type=\"password\" /&gt;\n      &lt;Input name=\"name\" type=\"text\" /&gt;\n      &lt;Button type=\"submit\"&gt;Register&lt;/Button&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre> <pre><code>// \u274c WRONG: Component imports use-case directly\n'use client';\n\nimport { RegisterUserUseCase } from '@/features/auth/application'; // \u274c\n\nexport function RegisterForm() {\n  const registerUseCase = new RegisterUserUseCase(/* ... */); // \u274c\n\n  async function handleSubmit(formData: FormData) {\n    await registerUseCase.execute({ ... }); // \u274c\n  }\n}\n</code></pre>"},{"location":"nextjs-integration/#state-management","title":"State Management","text":"<p>For global state: Custom hooks or Zustand when significantly complex.</p> <pre><code>// ui/hooks/use-auth.ts\nimport { create } from 'zustand';\n\ninterface AuthState {\n  user: User | null;\n  isAuthenticated: boolean;\n  login: (email: string, password: string) =&gt; Promise&lt;void&gt;;\n  logout: () =&gt; void;\n}\n\nexport const useAuth = create&lt;AuthState&gt;((set) =&gt; ({\n  user: null,\n  isAuthenticated: false,\n\n  login: async (email, password) =&gt; {\n    // Call server action or API route\n    const result = await loginAction(email, password);\n    set({ user: result.user, isAuthenticated: true });\n  },\n\n  logout: () =&gt; {\n    set({ user: null, isAuthenticated: false });\n  },\n}));\n\n// Usage in component\nimport { useAuth } from '@/ui/hooks';\n\nexport function UserMenu() {\n  const { user, logout } = useAuth();\n\n  return (\n    &lt;div&gt;\n      &lt;span&gt;{user?.name}&lt;/span&gt;\n      &lt;button onClick={logout}&gt;Logout&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"nextjs-integration/#barrel-exports-for-clean-imports","title":"Barrel Exports for Clean Imports","text":"<pre><code>// \u2705 CORRECT: Import from barrel exports\nimport { useUserData } from '@/ui/hooks';\nimport { Button, Card } from '@/ui/components/shared';\nimport { LoginForm } from '@/ui/components/auth';\nimport { RegisterUserUseCase } from '@/features/auth/application';\n\n// \u274c WRONG: Import from deep paths\nimport { useUserData } from '@/ui/hooks/use-user-data';\nimport { Button } from '@/ui/components/shared/button';\nimport { LoginForm } from '@/ui/components/auth/login-form';\nimport { RegisterUserUseCase } from '@/features/auth/application/use-cases/register-user/register-user-use-case';\n</code></pre> <p>Exception: Relative imports within same directory are allowed.</p> <pre><code>// Within features/auth/domain/entities/\n// user.ts\nimport { Email, UserId } from '../value-objects'; // \u2705 Relative import OK\nimport { UserStatus } from './user-status'; // \u2705 Same directory OK\n</code></pre>"},{"location":"nextjs-integration/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Code Style &amp; Patterns</p> <p>Next: Common Patterns \u2192</p>"},{"location":"philosophy-core-principles/","title":"Philosophy & Core Principles","text":""},{"location":"philosophy-core-principles/#philosophy-core-principles","title":"Philosophy &amp; Core Principles","text":""},{"location":"philosophy-core-principles/#what-i-value","title":"What I Value","text":"<ol> <li>Domain Isolation - Business rules are pure, reusable, and independent of frameworks</li> <li>Simple Vocabulary - Clear, descriptive naming over jargon</li> <li>Dependency Inversion - Abstractions over concretions at every boundary</li> <li>Declarative Over Imperative - Express what, not how</li> <li>Fast Tests - Domain/use-case tests run in &lt;50ms each</li> <li>Developer Ergonomics - Easy to navigate, understand, and modify</li> <li>Zero Framework Coupling in Core - Business logic never imports from frameworks</li> </ol>"},{"location":"philosophy-core-principles/#what-i-avoid","title":"What I Avoid","text":"<ul> <li>\u274c Heavy hexagonal architecture jargon (\"ports\", \"gateways\", \"presenters\" as type names)</li> <li>\u274c Framework dependencies in domain/application layers</li> <li>\u274c Heavy mocking frameworks (prefer test doubles)</li> <li>\u274c Generic <code>lib/</code> junk drawers</li> <li>\u274c Direct database/SDK access from UI or handlers</li> <li>\u274c <code>any</code> types</li> <li>\u274c Mutable state in domain logic</li> <li>\u274c Premature optimization</li> </ul>"},{"location":"philosophy-core-principles/#architecture-philosophy","title":"Architecture Philosophy","text":"<p>Clean Architecture with Functional Programming Bias</p> <ul> <li>Pure functions for domain logic whenever possible</li> <li>Classes for entities with behavior and use-cases with dependencies</li> <li>Interfaces for all architectural boundaries</li> <li>Explicit composition over DI containers (type safety + simplicity)</li> <li>Immutability by default (<code>const</code>, spread operators, no mutations)</li> <li>Push errors upward - don't catch too early</li> </ul>"},{"location":"philosophy-core-principles/#navigation","title":"Navigation","text":"<p>Next: Architecture Layers \u2192</p>"},{"location":"summary-quick-reference-checklist/","title":"Quick Reference","text":""},{"location":"summary-quick-reference-checklist/#summary-quick-reference-checklist","title":"Summary: Quick Reference Checklist","text":"<p>When coding, verify:</p>"},{"location":"summary-quick-reference-checklist/#layer-rules","title":"\u2705 Layer Rules","text":"<ul> <li> Domain never imports from application or infrastructure</li> <li> Application only imports from domain</li> <li> Infrastructure can import from anywhere</li> <li> No framework code in domain or application</li> </ul>"},{"location":"summary-quick-reference-checklist/#dependency-inversion","title":"\u2705 Dependency Inversion","text":"<ul> <li> Interfaces defined in domain</li> <li> Implementations in infrastructure</li> <li> Use-cases depend on interfaces, not concretions</li> <li> Constructor injection used everywhere</li> </ul>"},{"location":"summary-quick-reference-checklist/#use-cases","title":"\u2705 Use Cases","text":"<ul> <li> Every use-case has <code>execute()</code> method</li> <li> Explicit <code>Input</code> and <code>Output</code> types</li> <li> Use-cases orchestrate, don't contain deep business logic</li> <li> Business logic lives in entities/value objects</li> </ul>"},{"location":"summary-quick-reference-checklist/#testing","title":"\u2705 Testing","text":"<ul> <li> Domain/use-case tests use test doubles, not mocks</li> <li> Tests co-located with implementation</li> <li> Fast unit tests (&lt;50ms)</li> <li> Integration tests for infrastructure</li> </ul>"},{"location":"summary-quick-reference-checklist/#naming-organization","title":"\u2705 Naming &amp; Organization","text":"<ul> <li> Feature-based folders</li> <li> Barrel exports (<code>index.ts</code>) everywhere</li> <li> Descriptive names (no abbreviations)</li> <li> Consistent file naming patterns</li> </ul>"},{"location":"summary-quick-reference-checklist/#nextjs-integration","title":"\u2705 Next.js Integration","text":"<ul> <li> Routes/Server Actions call use-cases (not repositories)</li> <li> Components in <code>ui/</code> folder</li> <li> No business logic in components</li> <li> State management in custom hooks</li> </ul>"},{"location":"summary-quick-reference-checklist/#code-style","title":"\u2705 Code Style","text":"<ul> <li> Functional programming bias (pure functions)</li> <li> Immutability (<code>const</code>, spread operators)</li> <li> Declarative over imperative</li> <li> Principle-based comments</li> <li> Zero <code>any</code> types</li> </ul>"},{"location":"summary-quick-reference-checklist/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Migration Strategies</p> <p>Next: Appendix: Example Project Structure \u2192</p>"},{"location":"testing-strategy/","title":"Testing Strategy","text":""},{"location":"testing-strategy/#testing-strategy","title":"Testing Strategy","text":""},{"location":"testing-strategy/#testing-pyramid","title":"Testing Pyramid","text":"<pre><code>        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502   E2E (5%)  \u2502  Playwright, user flows\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 Integration \u2502  API routes, DB, external services\n        \u2502    (25%)    \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502    Unit     \u2502  Domain, use-cases, pure functions\n        \u2502    (70%)    \u2502  &lt;50ms each\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"testing-strategy/#test-organization","title":"Test Organization","text":"<p>Co-locate tests within architectural layers:</p> <pre><code>features/auth/\n\u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u251c\u2500\u2500 user.ts\n\u2502   \u2502   \u2514\u2500\u2500 user.test.ts              # \u2705 Co-located\n\u2502   \u251c\u2500\u2500 value-objects/\n\u2502   \u2502   \u251c\u2500\u2500 email.ts\n\u2502   \u2502   \u2514\u2500\u2500 email.test.ts             # \u2705 Co-located\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 use-cases/\n\u2502   \u2502   \u251c\u2500\u2500 register-user/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 register-user-use-case.ts\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 register-user-use-case.test.ts  # \u2705 Co-located\n\u251c\u2500\u2500 infrastructure/\n\u2502   \u2514\u2500\u2500 repositories/\n\u2502       \u251c\u2500\u2500 prisma-user-repository.ts\n\u2502       \u2514\u2500\u2500 prisma-user-repository.integration.test.ts  # \u2705 Integration test\n</code></pre>"},{"location":"testing-strategy/#test-doubles-over-mocking-frameworks","title":"Test Doubles Over Mocking Frameworks","text":"<p>Prefer Fake implementations (test doubles) over mocking libraries.</p> <pre><code>// \u2705 CORRECT: Fake implementation\n// infrastructure/test-doubles/in-memory-user-repository.ts\nexport class InMemoryUserRepository implements UserRepository {\n  private users = new Map&lt;string, User&gt;();\n\n  async findById(id: UserId): Promise&lt;User | null&gt; {\n    return this.users.get(id.value) || null;\n  }\n\n  async save(user: User): Promise&lt;void&gt; {\n    this.users.set(user.id.value, user);\n  }\n\n  // Test helper\n  clear(): void {\n    this.users.clear();\n  }\n}\n\n// Test\ndescribe('RegisterUserUseCase', () =&gt; {\n  it('should register a new user', async () =&gt; {\n    const userRepo = new InMemoryUserRepository(); // \u2705 Fake\n    const emailService = new FakeEmailService(); // \u2705 Fake\n    const useCase = new RegisterUserUseCase(userRepo, emailService);\n\n    const result = await useCase.execute({\n      email: 'test@example.com',\n      password: 'password123',\n      name: 'Test User',\n    });\n\n    expect(result.success).toBe(true);\n    const user = await userRepo.findById(UserId.create(result.userId));\n    expect(user).not.toBeNull();\n  });\n});\n</code></pre> <pre><code>// \u274c WRONG: Heavy mocking\nimport { mock } from 'jest-mock-extended';\n\ndescribe('RegisterUserUseCase', () =&gt; {\n  it('should register a new user', async () =&gt; {\n    const userRepo = mock&lt;UserRepository&gt;(); // \u274c Mock framework\n    userRepo.findByEmail.mockResolvedValue(null); // \u274c Mock setup\n    userRepo.save.mockResolvedValue(undefined); // \u274c Mock setup\n\n    // Test becomes brittle and couples to implementation details\n  });\n});\n</code></pre>"},{"location":"testing-strategy/#unit-test-principles","title":"Unit Test Principles","text":"<ol> <li>Fast: &lt;50ms per test</li> <li>Isolated: No database, no network, no filesystem</li> <li>Pure: Test domain logic with pure functions and test doubles</li> <li>Focused: One assertion per test (generally)</li> </ol> <pre><code>// domain/entities/user.test.ts\ndescribe('User', () =&gt; {\n  describe('canAccessFeature', () =&gt; {\n    it('should allow access when user is active and has permission', () =&gt; {\n      const user = User.create({\n        id: UserId.create('1'),\n        email: Email.create('test@example.com'),\n        profile: UserProfile.create({ tier: 'premium' }),\n        status: UserStatus.active(),\n      });\n\n      const canAccess = user.canAccessFeature(Feature.ADVANCED_ANALYTICS);\n\n      expect(canAccess).toBe(true);\n    });\n\n    it('should deny access when user is inactive', () =&gt; {\n      const user = User.create({\n        id: UserId.create('1'),\n        email: Email.create('test@example.com'),\n        profile: UserProfile.create({ tier: 'premium' }),\n        status: UserStatus.suspended(),\n      });\n\n      const canAccess = user.canAccessFeature(Feature.ADVANCED_ANALYTICS);\n\n      expect(canAccess).toBe(false);\n    });\n  });\n});\n</code></pre>"},{"location":"testing-strategy/#integration-test-principles","title":"Integration Test Principles","text":"<p>Test real integrations: databases, APIs, file systems</p> <pre><code>// infrastructure/repositories/prisma-user-repository.integration.test.ts\nimport { PrismaClient } from '@prisma/client';\n\ndescribe('PrismaUserRepository (integration)', () =&gt; {\n  let prisma: PrismaClient;\n  let repo: PrismaUserRepository;\n\n  beforeAll(async () =&gt; {\n    prisma = new PrismaClient();\n    await prisma.$connect();\n  });\n\n  afterAll(async () =&gt; {\n    await prisma.$disconnect();\n  });\n\n  beforeEach(async () =&gt; {\n    await prisma.user.deleteMany(); // Clean slate\n    repo = new PrismaUserRepository(prisma);\n  });\n\n  it('should save and retrieve a user', async () =&gt; {\n    const user = User.create({\n      id: UserId.create('1'),\n      email: Email.create('test@example.com'),\n      profile: UserProfile.create({ name: 'Test' }),\n    });\n\n    await repo.save(user);\n    const retrieved = await repo.findById(user.id);\n\n    expect(retrieved).not.toBeNull();\n    expect(retrieved!.email.value).toBe('test@example.com');\n  });\n});\n</code></pre>"},{"location":"testing-strategy/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Type System &amp; Validation</p> <p>Next: Error Handling \u2192</p>"},{"location":"type-system-validation/","title":"Type System & Validation","text":""},{"location":"type-system-validation/#type-system-validation","title":"Type System &amp; Validation","text":""},{"location":"type-system-validation/#interface-vs-type","title":"Interface vs Type","text":"<p>Use <code>interface</code> for: - Contracts (repository interfaces, service interfaces) - Object shapes that might be extended - Public APIs</p> <p>Use <code>type</code> for: - Unions: <code>type Status = 'active' | 'inactive'</code> - Intersections: <code>type UserWithProfile = User &amp; Profile</code> - Mapped types: <code>type Readonly&lt;T&gt; = { readonly [K in keyof T]: T[K] }</code> - Primitives: <code>type UserId = string</code></p> <pre><code>// \u2705 Interface for contracts\nexport interface UserRepository {\n  findById(id: UserId): Promise&lt;User | null&gt;;\n}\n\n// \u2705 Type for unions\nexport type UserStatus = 'active' | 'suspended' | 'deleted';\n\n// \u2705 Type for intersections\nexport type EnrichedUser = User &amp; { profile: UserProfile };\n</code></pre>"},{"location":"type-system-validation/#class-vs-interface","title":"Class vs Interface","text":"<p>Use <code>class</code> for: - Entities with behavior (domain objects) - Use-cases (application services) - Value objects with validation</p> <p>Use <code>interface</code> for: - Contracts (repositories, services) - DTOs (data transfer objects) - Configuration objects</p> <pre><code>// \u2705 Class for entity with behavior\nexport class User {\n  constructor(\n    public readonly id: UserId,\n    private status: UserStatus\n  ) {}\n\n  activate(): void {\n    this.status = 'active';\n  }\n\n  isActive(): boolean {\n    return this.status === 'active';\n  }\n}\n\n// \u2705 Interface for contract\nexport interface UserRepository {\n  findById(id: UserId): Promise&lt;User | null&gt;;\n}\n\n// \u2705 Interface for DTO\nexport interface RegisterUserInput {\n  email: string;\n  password: string;\n}\n</code></pre>"},{"location":"type-system-validation/#type-only-files","title":"Type-Only Files","text":"<p>Keep types in separate <code>types.ts</code> files for clarity.</p> <pre><code>// features/auth/application/use-cases/register-user/types.ts\nexport interface RegisterUserInput {\n  email: string;\n  password: string;\n  name: string;\n}\n\nexport interface RegisterUserOutput {\n  userId: string;\n  success: boolean;\n}\n\n// features/auth/application/use-cases/register-user/register-user-use-case.ts\nimport { RegisterUserInput, RegisterUserOutput } from './types';\n\nexport class RegisterUserUseCase {\n  async execute(input: RegisterUserInput): Promise&lt;RegisterUserOutput&gt; {\n    // ...\n  }\n}\n\n// features/auth/application/use-cases/register-user/index.ts\nexport { RegisterUserUseCase } from './register-user-use-case';\nexport type { RegisterUserInput, RegisterUserOutput } from './types';\n</code></pre>"},{"location":"type-system-validation/#zod-validation","title":"Zod Validation","text":"<p>Use Zod for: - Runtime validation at boundaries (API routes, form inputs) - Domain value object validation - External data validation (API responses)</p> <p>Location: - Domain validation schemas \u2192 <code>domain/schemas/</code> - Boundary validation \u2192 co-located with handler/component</p> <pre><code>// domain/value-objects/email.ts\nimport { z } from 'zod';\n\nconst EmailSchema = z.string().email().max(255);\n\nexport class Email {\n  private constructor(public readonly value: string) {}\n\n  static create(value: string): Email {\n    const result = EmailSchema.safeParse(value);\n    if (!result.success) {\n      throw new InvalidEmailError(value);\n    }\n    return new Email(result.data);\n  }\n\n  isValid(): boolean {\n    return EmailSchema.safeParse(this.value).success;\n  }\n}\n\n// app/api/auth/register/route.ts\nimport { z } from 'zod';\n\nconst RegisterRequestSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n  name: z.string().min(1),\n});\n\nexport async function POST(request: Request) {\n  const body = await request.json();\n  const validated = RegisterRequestSchema.parse(body); // Throws if invalid\n\n  const result = await auth.registerUser.execute(validated);\n  return Response.json(result);\n}\n</code></pre>"},{"location":"type-system-validation/#type-inference-vs-explicit-types","title":"Type Inference vs Explicit Types","text":"<p>Default: Explicit return types, inferred locals</p> <pre><code>// \u2705 CORRECT: Explicit return type, inferred locals\nexport class RegisterUserUseCase {\n  async execute(input: RegisterUserInput): Promise&lt;RegisterUserOutput&gt; { // \u2705 Explicit\n    const email = Email.create(input.email); // \u2705 Inferred\n    const user = User.create({ email, ... }); // \u2705 Inferred\n    return { userId: user.id.value, success: true }; // \u2705 Type-checked against return type\n  }\n}\n\n// \u274c WRONG: No return type\nexport class RegisterUserUseCase {\n  async execute(input: RegisterUserInput) { // \u274c No return type\n    // ...\n  }\n}\n</code></pre>"},{"location":"type-system-validation/#zero-any-types","title":"Zero <code>any</code> Types","text":"<p>Never use <code>any</code>. Use <code>unknown</code> when type is truly unknown.</p> <pre><code>// \u274c WRONG\nfunction parseJson(json: string): any { // \u274c\n  return JSON.parse(json);\n}\n\n// \u2705 CORRECT\nfunction parseJson&lt;T&gt;(json: string, schema: z.ZodType&lt;T&gt;): T {\n  const data: unknown = JSON.parse(json); // \u2705 unknown until validated\n  return schema.parse(data); // \u2705 Now T\n}\n</code></pre>"},{"location":"type-system-validation/#navigation","title":"Navigation","text":"<p>\u2190 Previous: Dependency Management</p> <p>Next: Testing Strategy \u2192</p>"}]}